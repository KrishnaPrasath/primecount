'\" t
.\"     Title: primecount
.\"    Author: [see the "AUTHOR" section]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 10/31/2019
.\"    Manual: \ \&
.\"    Source: \ \&
.\"  Language: English
.\"
.TH "PRIMECOUNT" "1" "10/31/2019" "\ \&" "\ \&"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
primecount \- count prime numbers
.SH "SYNOPSIS"
.sp
\fBprimecount\fR x [options]
.SH "DESCRIPTION"
.sp
Count the number of primes less than or equal to x (<= 10^31) using fast implementations of the combinatorial prime counting function algorithms\&. By default primecount counts primes using Xavier Gourdon\(cqs algorithm which has a runtime complexity of O(x^(2/3) / log^2 x) operations and uses O(x^(2/3) * log^3 x) memory\&. primecount is multi\-threaded, it uses all available CPU cores by default\&.
.SH "OPTIONS"
.PP
\fB\-d\fR, \fB\-\-deleglise\-rivat\fR
.RS 4
Count primes using the Deleglise\-Rivat algorithm\&.
.RE
.PP
\fB\-g\fR, \fB\-\-gourdon\fR
.RS 4
Count primes using Xavier Gourdon\(cqs algorithm (default algorithm)\&.
.RE
.PP
\fB\-l\fR, \fB\-\-legendre\fR
.RS 4
Count primes using Legendre\(cqs formula\&.
.RE
.PP
\fB\-\-lehmer\fR
.RS 4
Count primes using Lehmer\(cqs formula\&.
.RE
.PP
\fB\-\-lmo\fR
.RS 4
Count primes using the Lagarias\-Miller\-Odlyzko algorithm\&.
.RE
.PP
\fB\-m\fR, \fB\-\-meissel\fR
.RS 4
Count primes using Meissel\(cqs formula\&.
.RE
.PP
\fB\-\-Li\fR
.RS 4
Approximate pi(x) using the logarithmic integral\&.
.RE
.PP
\fB\-\-Li\-inverse\fR
.RS 4
Approximate the nth prime using Li^\-1(x)\&.
.RE
.PP
\fB\-n\fR, \fB\-\-nth\-prime\fR
.RS 4
Calculate the nth prime\&.
.RE
.PP
\fB\-p\fR, \fB\-\-primesieve\fR
.RS 4
Count primes using the sieve of Eratosthenes\&.
.RE
.PP
\fB\-\-phi=\fR<a>
.RS 4
phi(x, a) counts the numbers <= x that are not divisible by any of the first a primes\&.
.RE
.PP
\fB\-\-Ri\fR
.RS 4
Approximate pi(x) using the Riemann R function\&.
.RE
.PP
\fB\-\-Ri\-inverse\fR
.RS 4
Approximate the nth prime using Ri^\-1(x)\&.
.RE
.PP
\fB\-s\fR[N], \fB\-\-status\fR[=N]
.RS 4
Show the computation progress e\&.g\&. 1%, 2%, 3%, \&... Show N digits after the decimal point:
\fB\-\-status=1\fR
prints 99\&.9%\&.
.RE
.PP
\fB\-\-test\fR
.RS 4
Run various correctness tests and exit\&.
.RE
.PP
\fB\-\-time\fR
.RS 4
Print the time elapsed in seconds\&.
.RE
.PP
\fB\-t\fR<N>, \fB\-\-threads=\fR<N>
.RS 4
Set the number of threads, 1 <= N <= CPU cores\&. By default primecount uses all available CPU cores\&.
.RE
.PP
\fB\-v\fR, \fB\-\-version\fR
.RS 4
Print version and license information\&.
.RE
.PP
\fB\-h\fR, \fB\-\-help\fR
.RS 4
Print this help menu\&.
.RE
.SH "ADVANCED OPTIONS FOR THE DELEGLISE\-RIVAT ALGORITHM"
.PP
\fB\-\-P2\fR
.RS 4
Compute the 2nd partial sieve function\&.
.RE
.PP
\fB\-\-S1\fR
.RS 4
Compute the ordinary leaves\&.
.RE
.PP
\fB\-\-S2\-trivial\fR
.RS 4
Compute the trivial special leaves\&.
.RE
.PP
\fB\-\-S2\-easy\fR
.RS 4
Compute the easy special leaves\&.
.RE
.PP
\fB\-\-S2\-hard\fR
.RS 4
Compute the hard special leaves\&.
.RE
.SS "Tuning factor"
.sp
The \fBalpha\fR tuning factor mainly balances the computation of the \fBS2_easy\fR and \fBS2_hard\fR formulas\&. By increasing \fBalpha\fR the runtime of the \fBS2_hard\fR formula will usually decrease but the runtime of the \fBS2_easy\fR formula will increase\&. For large pi(x) computations with x >= 10^25 you can usually achieve a significant speedup by increasing \fBalpha\fR\&.
.sp
The \fBalpha\fR tuning factor is also very useful for verifying pi(x) computations\&. You compute pi(x) twice but for the second computation you use a slightly different \fBalpha\fR factor\&. If the results of both pi(x) computations match then pi(x) has been verified successfully\&.
.PP
\fB\-a\fR<N>, \fB\-\-alpha=\fR<N>
.RS 4
Tuning factor, 1 <= alpha <= x^(1/6)\&.
.RE
.SH "ADVANCED OPTIONS FOR XAVIER GOURDON\(cqS ALGORITHM"
.PP
\fB\-\-AC\fR
.RS 4
Compute Gourdon\(cqs A + C formulas\&.
.RE
.PP
\fB\-\-B\fR
.RS 4
Compute Gourdon\(cqs B formula\&.
.RE
.PP
\fB\-\-D\fR
.RS 4
Compute Gourdon\(cqs D formula\&.
.RE
.PP
\fB\-\-Phi0\fR
.RS 4
Compute the Phi0 formula\&.
.RE
.PP
\fB\-\-Sigma\fR
.RS 4
Compute the 7 Sigma formulas\&.
.RE
.SS "Tuning factors"
.sp
The \fBalpha_y\fR and \fBalpha_z\fR tuning factors mainly balance the computation of the A, B, C and D formulas\&. When \fBalpha_y\fR is decreased but \fBalpha_z\fR is increased then the runtime of the B formula will increase but the runtime of the A, C and D formulas will decrease\&. For large pi(x) computations with x >= 10^25 you can usually achieve a significant speedup by decreasing \fBalpha_y\fR and increasing \fBalpha_z\fR\&. For convenience when you increase \fBalpha_z\fR using \fB\-\-alpha\-z=N\fR then \fBalpha_y\fR is automatically decreased\&.
.sp
Both the \fBalpha_y\fR and \fBalpha_z\fR tuning factors are also very useful for verifying pi(x) computations\&. You compute pi(x) twice but for the second computation you use a slightly different \fBalpha_y\fR or \fBalpha_z\fR factor\&. If the results of both pi(x) computations match then pi(x) has been verified successfully\&.
.PP
\fB\-\-alpha\-y=\fR<N>
.RS 4
Tuning factor, 1 <= alpha_y <= x^(1/6)\&.
.RE
.PP
\fB\-\-alpha\-z=\fR<N>
.RS 4
Tuning factor, 1 <= alpha_z <= x^(1/6)\&.
.RE
.SH "EXAMPLES"
.PP
\fBprimecount 1000\fR
.RS 4
Count the primes <= 1000\&.
.RE
.PP
\fBprimecount 1e17 \-\-status\fR
.RS 4
Count the primes <= 10^17 and print status information\&.
.RE
.PP
\fBprimecount 1e15 \-\-threads=1 \-\-time\fR
.RS 4
Count the primes <= 10^15 using a single thread and print the time elapsed\&.
.RE
.SH "AUTHOR"
.sp
Kim Walisch <kim\&.walisch@gmail\&.com>
